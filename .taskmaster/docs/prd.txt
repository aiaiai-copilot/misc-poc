# MISC (MindSection) - Consolidated Product Requirements Document for TaskMaster AI

## Executive Summary

MISC is a minimalist information management system based on a single principle: everything is tags. Each record represents a set of words (tags) separated by spaces. The system eliminates the barrier between thought and recording, offering instant capture and search of information without traditional data organization structures.

In a world overloaded with complex information organization systems, MISC offers a radical alternative. We remove forms, fields, folders, document types - leaving only the essence: words and connections between them.

---

# PART 1: PRODUCT VISION AND PHILOSOPHY

## Philosophy

Each record is simply a set of words separated by spaces. Each word is simultaneously both content and a way to find that content.

## Key Problem

Existing note-taking systems force users to think about structure instead of content:
- Which folder to save to?
- Which document type to choose?
- Which fields to fill?
- How to name it correctly?

This is cognitive load that interferes with the main thing - rapid information capture.

## Solution

MISC eliminates the barrier between thought and recording:

1. **Recording**: Simply enter words separated by spaces
2. **Search**: Enter any words from the record - find everything that contains them

Usage example:
```
peter ivanov phone 89151234455 birthday march 15
github password qwerty123 igor@gmail.com
alla petrova birthday 8 april
google password qwerty567 alex@gmail.com
meeting tomorrow 15:00 office project_alpha
```

Typing "peter phone" - find Peter's contact.
Typing "password" - see all saved passwords.
Typing "birthday" - see a list of birthdays you need.

## Target Audience

### Primary
- **Information workers**: Those who constantly work with diverse information
- **Minimalists**: Admirers of simple and elegant solutions
- **Advanced users**: Those tired of traditional systems' limitations

### Secondary
- **Regular users**: Looking for a simple alternative to complex applications
- **Developers**: For quick technical notes and snippets
- **Students and researchers**: For capturing scattered facts and ideas

## Key Product Principles

1. **Radical simplicity**: One mechanism for all types of information
2. **Zero entry barrier**: Requires no learning
3. **Speed priority**: Instant thought capture
4. **Transparency**: User always understands how the system works
5. **No structure - there is freedom**: 
   - User decides how to interpret their records
   - Word order is preserved for natural readability
6. **Speed over formality**: Instant thought capture without unnecessary actions
7. **Universality through simplicity**: One mechanism for all information types

## Manifesto

MISC is not just a note-taking application. It's an information management philosophy where the absence of rigidity becomes an advantage. Where less truly means more.

We believe the best interface is minimalist, and the best system is one that doesn't need to be learned.

---

# PART 2: ARCHITECTURE AND TECHNICAL PRINCIPLES

## Architectural Principles

- **Clean Architecture**: Business logic independence from implementation details
- **Domain-First**: Domain model is developed first and doesn't depend on UI or DB
- **Test-Driven Development**: Development through testing from day one
- **Dependency Inversion**: Dependencies are directed towards the center (to domain)
- **SOLID principles**: Each component has a single responsibility
- **YAGNI for prototype**: Don't implement what's not needed now
- **Preparation for evolution**: Data structure ready for future changes

## Architecture Layers

| Layer | Responsibility | Depends on | Testing |
|-------|----------------|------------|---------|
| Domain | Business logic, rules | Nothing | >95% coverage |
| Application | Orchestration, use cases | Domain | >90% coverage |
| Infrastructure | Storage, external services | Domain (through interfaces) | Integration tests |
| Presentation | UI, input processing | Application | Component + E2E tests |

## Technology Stack

- **Monorepo**: yarn workspaces for package management
- **Language**: TypeScript for all layers
- **Node.js**: v22.18.0 (specified in .nvmrc)
- **Frontend framework**: React (presentation layer details)
- **CLI framework**: Ink (React for terminal)
- **Bundler**: Vite for web, esbuild for CLI
- **Testing**: Jest/Vitest for unit tests, Testing Library for components

---

# PART 3: FUNCTIONAL REQUIREMENTS

## Core Functionality

### Record Management

- **Record creation**: Input a set of tags separated by spaces
- **Record search**: Search by any combination of tags (AND logic)
- **Record editing**: Complete replacement of record content
- **Record deletion**: Permanent deletion
- **Record uniqueness**: Record = unique set of tags (order doesn't matter for identification)
- **Tag order preservation**: When displaying records, tags are shown in the order user entered them

### Working with Tags

- **Tag definition**: Any sequence of characters without spaces
- **Tag restrictions**: 
  - Forbidden JSON service characters: `{}[]:,"\`
  - Support for all other Unicode characters
  - Automatic lowercase conversion (configurable)
  - Optional diacritic removal (configurable)
- **Tag normalization**:
  - Lowercase conversion for search
  - Diacritic removal (Ã©â†’e, Ã±â†’n) for improved search (optional)
  - Example: "CafÃ©" and "cafe" will be found by the same query
- **Auto-completion**: Suggestions based on existing tags
- **Usage statistics**: Counting tag usage frequency
- **Tag order in records**: 
  - Tag input order is preserved for each record
  - When editing, user can change tag order
  - Order matters for readability but doesn't affect record uniqueness

### Search Interface

- **Incremental search**: Results update as you type
- **Tag cloud**: Displayed when results don't fit on screen
  - Tag size proportional to usage frequency
  - Clicking a tag adds it to search query
- **Record list**: Displayed when results fit on screen
  - Sorted by creation date (newest first)
  - Display full record content (when possible)

### Export/Import

#### Functionality
- **Export all data**: In JSON format with versioning
- **Import data**: Complete replacement of existing data (clear + load)
- **Format versioning**: For compatibility assurance
- **Format simplicity**: Only user data, no internal identifiers

#### Data Format
```json
{
  "version": "1.0",
  "records": [
    {
      "content": "ToDo meeting Petrov 15:00",
      "createdAt": "2024-01-01T10:00:00Z",
      "updatedAt": "2024-01-01T10:00:00Z"
    }
  ],
  "metadata": {
    "exportedAt": "2024-01-15T12:00:00Z",
    "recordCount": 42,
    "normalizationRules": {
      "caseSensitive": false,
      "removeAccents": false
    }
  }
}
```

#### Import/Export Security

**Export:**
- Not exported: Record and tag UUIDs
- Exported: Content, creation/update dates
- Format: Standard JSON with versioning
- Size: Warning when exporting > 1000 records

**Import:**
- Complete replacement: All existing data is deleted
- Warning: Mandatory user confirmation
- Backup: Automatic creation before import
- Validation: JSON structure check before import
- New UUIDs: All records and tags get new identifiers

---

# PART 4: USER INTERFACE

## Main Interface

- **Single input field**: Universal field for search and record creation
- **Adaptive display**: 
  - Search mode by default
  - Suggest creating a record when no results found
- **Minimalist design**: Focus on content, minimal visual elements
- **Status indicators**:
  - Search: Visual indication during debounce delay (e.g., ellipsis or spinner)
  - Loading: Indicator when performing operations

## Keyboard Management

- **Enter**: Save new record / Open selected for editing
- **Escape**: Clear input field
- **Tab**: Tag auto-completion
- **â†‘/â†“**: Navigate search results
- **Delete**: Delete selected record

## Main Interface Workflow Algorithm

### Single field input flow
```
User enters text
    â†“
Debounce 300ms
    â†“
Search records
    â†“
Found?
  â”œâ”€ Yes â†’ Fits on screen?
  â”‚       â”œâ”€ Yes â†’ Show list
  â”‚       â””â”€ No â†’ Show tag cloud
  â””â”€ No â†’ Suggest creating record
          â””â”€ Enter â†’ Create
```

### Import/Export flow
```
Export:
  User â†’ "Export" button â†’ JSON file (without UUIDs)

Import:
  User â†’ Select file â†’ Warning about replacing all data
    â†“
  Confirmation â†’ Complete deletion â†’ Import records â†’ Create new UUIDs
```

## UI States

```typescript
type UIMode = 
  | { type: 'empty' }
  | { type: 'searching'; query: string }
  | { type: 'list'; records: RecordDTO[] }
  | { type: 'cloud'; tags: TagCloudItemDTO[] }
  | { type: 'creating'; content: string }
  | { type: 'editing'; record: RecordDTO }
  | { type: 'no-results'; query: string }
  | { type: 'importing'; progress?: number }
  | { type: 'export-ready'; data: ExportDTO }
```

---

# PART 5: NON-FUNCTIONAL REQUIREMENTS

## Performance

- **Search response time**: < 100ms for 10,000 records
- **Save time**: < 50ms
- **Application size**: < 500KB (gzipped)
- **Application startup**: < 2 seconds
- **Auto-completion**: < 50ms for 10,000 tags
- **Display mode detection**: < 10ms for 100 records
- **Full import**: < 2sec for 1,000 records
- **Export**: < 1sec for 10,000 records

## Reliability

- **Data persistence**: Automatic saving without data loss
- **Validation**: Correctness checking at all levels
- **Error handling**: Graceful degradation, informative messages
- **Recovery**: Ability to recover from exported data

## Usability

- **Responsive design**: Adaptation to different screen sizes
- **Accessibility**: Support for keyboard-only navigation
- **Feedback**: Visual status indicators
- **UI response time**: < 16ms for smooth animations

## Testability

- **Unit testing**: All components should be testable in isolation
- **Integration testing**: Tests for interaction between layers
- **E2E testing**: Main user scenarios
- **Test data**: Ability to generate and load test data

## Modularity and Extensibility

- **Layer independence**: Changes in one layer should not require changes in others
- **Pluggable storage**: Ability to replace localStorage with other storage solutions
- **Function extensibility**: New features added without changing existing code
- **Configurability**: Settings extracted to configuration

## Compatibility

- **Browsers**: Latest 2 versions of Chrome, Firefox, Safari, Edge
- **Minimum resolution**: 320px width
- **JavaScript**: ES2020+ with transpilation

---

# PART 6: DOMAIN MODEL

## Entities

### Record

**Description**: Record - main system entity, represents user-saved information.

**Fields:**
- `id`: RecordId - unique record identifier
- `content`: RecordContent - record content as entered by user (preserves tag order)
- `tagIds`: Set<TagId> - set of tag identifiers (for fast search)
- `createdAt`: Date - creation date
- `updatedAt`: Date - last update date

**Behavior:**
- `hasTag(tagId: TagId)`: boolean - check tag presence
- `hasSameTagSet(other: Record)`: boolean - check for same tag set
- `equals(other: Record)`: boolean - compare by ID

**Invariants:**
- ID immutable after creation
- Content cannot be empty
- Content must contain at least one valid tag
- tagIds contains all tags from content (synchronization)

### Tag

**Description**: Tag as entity - unique concept in the system.

**Fields:**
- `id`: TagId - unique tag identifier
- `normalizedValue`: string - normalized form for search and uniqueness

**Behavior:**
- `equals(other: Tag)`: boolean - compare by ID

**Invariants:**
- ID immutable after creation
- normalizedValue unique in system

## Value Objects

- **RecordId**: Record identifier (UUID)
- **TagId**: Tag identifier (UUID)
- **RecordContent**: Record content - string of tags as entered by user
- **SearchQuery**: User search query with normalized tokens

## Domain Services

### TagNormalizer
**Description**: Tag normalization service.
**Rules:**
- Convert to lowercase
- Optionally: remove diacritics (in configuration)

### TagParser
**Description**: Service for parsing content into tags. Returns array of normalized tag values.

### TagValidator
**Description**: Token validation.
**Rules:**
- Length from 1 to 100 characters (configurable)
- Does not contain forbidden characters: `{}[]:,"\`
- Does not contain spaces

### RecordMatcher
**Description**: Service for checking record match against search query.
**Logic:**
- All tokens from query must be present in record (AND logic)
- Comparison by normalized values

### RecordDuplicateChecker
**Description**: Service for checking record uniqueness.
**Logic:**
- Records are duplicates if they have the same set of tagIds
- Order doesn't matter

---

# PART 7: APPLICATION LAYER - USE CASES

## CreateRecord

**Input:** `{ content: string }`  
**Output:** `RecordDTO`  
**Logic:**
1. Parse content into tokens
2. Validate each token
3. Normalize tokens
4. Find or create tags for each unique normalized value
5. Check for duplicate
6. Create Record with Set<TagId>
7. Save to repository
8. Return DTO

## SearchRecords

**Input:** `{ query: string }`  
**Output:** `SearchResultDTO`  
**Logic:**
1. Parse and normalize query
2. Find tags by normalized values
3. Find records containing ALL tags from query
4. Determine display mode (list/cloud)
5. Form result

## UpdateRecord

**Input:** `{ id: string, content: string }`  
**Output:** `RecordDTO`  
**Logic:**
1. Find record
2. Parse new content
3. Find/create tags
4. Check for duplicate (excluding current record)
5. Update record
6. Clean unused tags
7. Return DTO

## DeleteRecord

**Input:** `{ id: string }`  
**Output:** `void`  
**Logic:**
1. Find and delete record
2. Check and delete unused tags

## GetTagSuggestions

**Input:** `{ partial: string }`  
**Output:** `string[]`  
**Logic:**
1. Normalize partial
2. Find all tags starting with partial
3. Return normalized values for auto-completion

## ExportData

**Input:** `{ format: 'json' }`  
**Output:** `ExportDTO`  
**Logic:**
1. Get all records
2. Form JSON with content and metadata
3. DO NOT export record and tag UUIDs (only content and dates)

## ImportData

**Input:** `{ data: string, format: 'json' }`  
**Output:** `ImportResultDTO`  
**Logic:**
1. **FULL IMPORT**: Delete all existing records and tags
2. Parse JSON data
3. For each record from import:
   - Parse content
   - Create new tags (with new UUIDs)
   - Create new record (with new UUID)
   - Save to repository
4. Return import statistics

**âš ï¸ Important**: Import completely replaces all data in the system!

---

# PART 8: INFRASTRUCTURE AND STORAGE

## Storage Schema (localStorage)

```javascript
{
  "version": "2.1",
  
  // Tags - object for O(1) access by ID
  "tags": {
    "uuid-tag-1": {
      "id": "uuid-tag-1",
      "normalizedValue": "todo"
    }
  },
  
  // Records - object for O(1) access by ID
  "records": {
    "uuid-record-1": {
      "id": "uuid-record-1",
      "content": "ToDo meeting Petrov 15:00",
      "tagIds": ["uuid-tag-1", "uuid-tag-2", "uuid-tag-3", "uuid-tag-4"],
      "createdAt": "2024-01-01T10:00:00Z",
      "updatedAt": "2024-01-01T10:00:00Z"
    }
  },
  
  // Indexes for fast search
  "indexes": {
    // normalized value â†’ tag ID
    "normalizedToTagId": {
      "todo": "uuid-tag-1"
    },
    
    // tag ID â†’ array of record IDs
    "tagToRecords": {
      "uuid-tag-1": ["uuid-record-1", "uuid-record-2"]
    }
  }
}
```

**Why objects instead of arrays:**
- O(1) access by ID instead of O(n) search
- Critical for 10,000 records
- Easier updates and deletion

## Adapters

Repository implementation through localStorage with support for:
- Indexes for fast search
- deleteAll() method for full import
- Transactionality through UnitOfWork

## Ports (interfaces for Infrastructure)

**RecordRepository**: Record management
- CRUD operations
- Search by tags with AND logic
- Full cleanup for import

**TagRepository**: Tag management
- CRUD operations
- Search by normalized value
- Auto-completion by prefix
- Cleanup of unused tags

**UnitOfWork**: Pattern for operation transactionality

---

# PART 9: SETTINGS AND CONFIGURATION

## User Settings

### Basic Settings
- **Tag case sensitivity**: On/Off (default: off)
- **Remove diacritics**: On/Off (default: on)
- **Live search**: On/Off (default: on)
- **Interface language**: Auto-detection with ability to change

### Limits
- **Maximum tag length**: Configurable (default: 100 characters)
- **Maximum number of tags per record**: Configurable (default: 50)
- **Maximum storage size**: Warning when approaching limit

## System Configuration

**Tags:**
- maxLength: 100 characters
- maxPerRecord: 50 tags

**Normalization:**
- caseSensitive: false
- removeAccents: false

**Search:**
- debounceMs: 300
- liveSearch: true

**Display:**
- recordHeight: 60px
- Automatic list/cloud switching

**Storage:**
- maxSizeMB: 5
- backupBeforeImport: true

**Import/Export:**
- warningThreshold: 1000 records
- Format versioning

---

# PART 10: USER SCENARIOS

## First Use

1. User opens the application
2. Sees empty input field with placeholder
3. Starts typing tags separated by spaces
4. Presses Enter - record is saved
5. Field clears, ready for new record

## Information Search

1. User enters one or several tags
2. Sees results in real time
3. If many results - sees tag cloud
4. Clicks on tag in cloud for refinement
5. Finds needed record

## Record Editing

1. User finds record through search
2. Clicks on record or selects with arrows + Enter
3. Record loads into input field preserving original tag order
4. Edits content
5. Presses Enter - changes are saved

## Data Export/Import

1. **Export**: User clicks "Export" â†’ gets JSON file with all records
2. **Import**: 
   - User selects JSON file
   - Sees warning about complete data replacement
   - Confirms â†’ all old data is deleted
   - New data is loaded from file
   - Tags are automatically created based on content

---

# PART 11: DEVELOPMENT PLAN

## Development Principles

1. **TDD First**: Tests first, then implementation
2. **Inside-Out**: From domain to external layers
3. **Incremental**: Small iterations with working code
4. **No Mocks in Domain**: Domain layer tested without mocks
5. **CI from Day One**: Continuous integration from first commit

## Development Phases

### Phase 0: Project Initialization (1-2 days)

#### Tasks:
- Create repository and basic structure
- Set up yarn workspaces
- Set up TypeScript configuration
- Set up Jest for all packages
- Set up ESLint and Prettier
- Set up pre-commit hooks (Husky)
- Set up GitHub Actions for CI
- Create basic package.json for all packages

#### Readiness Criteria:
- Can run `yarn test` in any package
- CI runs on push and checks linting and tests
- Folder structure matches project-structure.md

### Phase 1: Domain Layer (3-5 days)

#### Implementation Order:

##### Day 1: Value Objects
- RecordId with tests (TDD)
- TagId with tests (TDD)
- RecordContent with tests (TDD)
- SearchQuery with tests (TDD)
- Factories for Value Objects
- Integration and refactoring

##### Day 2: Entities
- Tag entity with tests (TDD)
- TagFactory with tests
- Record entity with tests (TDD)
- RecordFactory with tests
- Invariant checking

##### Day 3: Domain Services
- TagNormalizer with tests (TDD)
- TagValidator with tests (TDD)
- TagParser with tests (TDD)
- RecordMatcher with tests (TDD)
- RecordDuplicateChecker with tests (TDD)

##### Day 4: Domain Errors and integration
- All Domain Errors with tests
- Result type and utilities
- Domain integration tests
- Refactoring and optimization
- Public API documentation

#### Success Metrics:
- Test coverage > 95%
- All tests pass < 1 sec
- No dependencies except shared package

### Phase 2: Application Layer (4-5 days)

#### Implementation Order:

##### Day 1: Basic Infrastructure
- Ports (Repository interfaces)
- Basic DTOs
- ApplicationError hierarchy
- ApplicationConfig
- Repository mocks for tests

##### Day 2-3: Core Use Cases
- CreateRecord use case (TDD)
- SearchRecords use case (TDD)
- UpdateRecord use case (TDD)
- DeleteRecord use case (TDD)
- SearchModeDetector service

##### Day 4: Import/Export
- ImportValidator with tests
- ExportFormatter with tests
- ImportData use case (TDD)
- ExportData use case (TDD)

##### Day 5: Additional Services
- GetTagSuggestions use case (TDD)
- TagCloudBuilder service
- ApplicationContainer
- Integration tests
- Documentation

#### Success Metrics:
- Test coverage > 90%
- Use cases don't depend on implementation details
- All operations return Result type

### Phase 3: Infrastructure Layer - localStorage (3-4 days)

#### Implementation Order:

##### Day 1: Storage Manager
- StorageSchema definition
- StorageManager with tests (TDD)
- Serialization/deserialization
- IndexManager with tests (TDD)
- Index optimization

##### Day 2: Repositories
- LocalStorageRecordRepository (TDD)
- CRUD operations with tests
- LocalStorageTagRepository (TDD)
- Search and auto-completion

##### Day 3: Unit of Work and migrations
- LocalStorageUnitOfWork
- Operation transactionality
- MigrationManager
- Schema versioning

##### Day 4: Integration and optimization
- Integration tests with real localStorage
- Performance tests
- Edge case handling (quota exceeded)
- Documentation

#### Success Metrics:
- Search 10,000 records < 100ms
- Save < 50ms
- Correct localStorage limits handling

### Phase 4: Presentation Layer - Web (5-6 days)

#### Implementation Order:

##### Day 1: Basic React Infrastructure
- Set up Vite
- Basic components and styles
- Contexts and providers
- ApplicationContext setup
- Integration with Application layer

##### Day 2: Main UI
- SearchInput component (TDD)
- Debounce and keyboard handling
- RecordList component (TDD)
- RecordItem with actions

##### Day 3: Tag Cloud and auto-completion
- TagCloud component (TDD)
- Interactivity and animations
- AutoComplete component (TDD)
- Integration with SearchInput

##### Day 4: Import/Export UI
- ImportExport components
- Dialogs and progress
- Error handling
- Client-side validation

##### Day 5: Integration and polish
- Keyboard shortcuts
- Responsive design
- Dark theme (optional)
- E2E tests for main scenarios
- Performance optimization

##### Day 6: Finalization
- Accessibility (a11y) checks
- Performance audit
- Bundle size optimization
- Component documentation

#### Success Metrics:
- Lighthouse score > 90
- Bundle size < 500KB (gzipped)
- FCP < 1.5s, TTI < 3s
- 100% keyboard navigable

### Phase 5: CLI version (3-4 days) [Optional]

#### Implementation Order:

##### Day 1: Basic structure
- Set up Ink
- Basic CLI components
- Integration with Application layer

##### Day 2: Commands
- add command
- search command
- update/delete commands

##### Day 3: Import/Export and finalization
- import/export commands
- Shell auto-completion
- Man pages

#### Success Metrics:
- All main operations available
- Response time < 100ms
- Works in pipe chains

### Phase 6: MVP with Backend

- Migration to PostgreSQL
- REST API / GraphQL
- Authorization and authentication
- Data synchronization
- Multi-user support

---

# PART 12: PROJECT STRUCTURE

## Overall Monorepo Structure

```
misc/
â”œâ”€â”€ packages/                    # Monorepo packages
â”‚   â”œâ”€â”€ domain/                  # Domain layer (core)
â”‚   â”œâ”€â”€ application/             # Application layer (use cases)
â”‚   â”œâ”€â”€ infrastructure/          # Infrastructure layer
â”‚   â”‚   â””â”€â”€ localStorage/        # localStorage implementation
â”‚   â”œâ”€â”€ presentation/            # Presentation layer
â”‚   â”‚   â”œâ”€â”€ web/                # Web application (React)
â”‚   â”‚   â””â”€â”€ cli/                # CLI application (Ink)
â”‚   â””â”€â”€ shared/                  # Shared utilities and types
â”œâ”€â”€ docs/                        # Documentation
â”œâ”€â”€ scripts/                     # Build and deploy scripts
â””â”€â”€ config/                      # Configuration files
```

## Detailed Domain Package Structure

```
domain/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ Record.ts
â”‚   â”‚   â”œâ”€â”€ Tag.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ value-objects/
â”‚   â”‚   â”œâ”€â”€ RecordId.ts
â”‚   â”‚   â”œâ”€â”€ TagId.ts
â”‚   â”‚   â”œâ”€â”€ RecordContent.ts
â”‚   â”‚   â”œâ”€â”€ SearchQuery.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ TagNormalizer.ts
â”‚   â”‚   â”œâ”€â”€ TagParser.ts
â”‚   â”‚   â”œâ”€â”€ TagValidator.ts
â”‚   â”‚   â”œâ”€â”€ RecordMatcher.ts
â”‚   â”‚   â”œâ”€â”€ RecordDuplicateChecker.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ errors/
â”‚   â”‚   â”œâ”€â”€ DomainError.ts
â”‚   â”‚   â”œâ”€â”€ InvalidRecordContentError.ts
â”‚   â”‚   â”œâ”€â”€ InvalidTagError.ts
â”‚   â”‚   â”œâ”€â”€ DuplicateRecordError.ts
â”‚   â”‚   â”œâ”€â”€ TagLimitExceededError.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ factories/
â”‚   â”‚   â”œâ”€â”€ RecordFactory.ts
â”‚   â”‚   â”œâ”€â”€ TagFactory.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ value-objects/
â”‚   â”œâ”€â”€ services/
â”‚   â””â”€â”€ test-utils/
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

## Detailed Application Package Structure

```
application/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ use-cases/
â”‚   â”‚   â”œâ”€â”€ CreateRecord/
â”‚   â”‚   â”œâ”€â”€ SearchRecords/
â”‚   â”‚   â”œâ”€â”€ UpdateRecord/
â”‚   â”‚   â”œâ”€â”€ DeleteRecord/
â”‚   â”‚   â”œâ”€â”€ GetTagSuggestions/
â”‚   â”‚   â”œâ”€â”€ ExportData/
â”‚   â”‚   â”œâ”€â”€ ImportData/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ ports/
â”‚   â”‚   â”œâ”€â”€ RecordRepository.ts
â”‚   â”‚   â”œâ”€â”€ TagRepository.ts
â”‚   â”‚   â”œâ”€â”€ UnitOfWork.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”œâ”€â”€ RecordDTO.ts
â”‚   â”‚   â”œâ”€â”€ SearchResultDTO.ts
â”‚   â”‚   â”œâ”€â”€ TagCloudItemDTO.ts
â”‚   â”‚   â”œâ”€â”€ ExportDTO.ts
â”‚   â”‚   â”œâ”€â”€ ImportResultDTO.ts
â”‚   â”‚   â”œâ”€â”€ ValidationResultDTO.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ SearchModeDetector.ts
â”‚   â”‚   â”œâ”€â”€ TagCloudBuilder.ts
â”‚   â”‚   â”œâ”€â”€ ImportValidator.ts
â”‚   â”‚   â”œâ”€â”€ ExportFormatter.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ errors/
â”‚   â”‚   â””â”€â”€ ApplicationError.ts
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ ApplicationConfig.ts
â”‚   â”‚   â””â”€â”€ defaultConfig.ts
â”‚   â””â”€â”€ container/
â”‚       â”œâ”€â”€ ApplicationContainer.ts
â”‚       â””â”€â”€ ApplicationContainerFactory.ts
â”œâ”€â”€ tests/
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

## Package Dependencies

```
shared â†’ nobody
   â†‘
domain â†’ shared
   â†‘
application â†’ domain, shared
   â†‘
infrastructure â†’ domain, application, shared
   â†‘
presentation â†’ application, shared
```

## Conventions and Rules

### Naming
- **Packages**: `@misc/package-name`
- **Files**: PascalCase for classes/interfaces, camelCase for functions
- **Tests**: `*.test.ts` or `*.spec.ts`
- **Styles**: CSS Modules with `*.module.css`

### Import Rules
- Absolute imports within package: `@/entities/Record`
- Imports between packages: `@misc/domain`
- Import grouping: external â†’ misc packages â†’ local

---

# PART 13: METRICS AND SUCCESS CRITERIA

## Target Metrics

- Time to first record: < 10 seconds
- Learning time: < 1 minute
- Usage universality: 80% of users for 3+ information types
- Retention: 60% active users after a month
- **Test coverage**: 
  - Domain layer: > 95%
  - Use Cases: > 90%
  - Overall coverage: > 80%

## Technical Metrics

- Test coverage: > 80% overall, > 95% domain
- Build time: < 30 seconds
- Bundle size: < 500KB gzipped
- Performance: 60 FPS for all interactions
- Zero critical bugs in production

## Product Metrics

- Time to productive use: < 1 minute
- NPS: > 50 after a month of use
- Daily Active Users: > 100 for validation
- Number of records per user: > 50 in first month
- Use case diversity: 3+ information types per user

## Code Quality Metrics

- Cyclomatic complexity: < 10 for all functions
- Code duplication: < 3%
- Technical debt (by SonarQube): < 5 days
- PR review time: < 24 hours
- Average bug fix time: < 48 hours

## Acceptance Criteria

### Functional Criteria
- All main use cases work according to specification
- Data is saved and restored correctly
- Search finds all relevant records
- Export/import works without data loss
- Hotkeys work as described
- Normalization with diacritics works correctly

### Architectural Criteria
- Domain layer has no dependencies on other layers
- Use cases are tested without UI and DB
- Repositories are easily replaceable (localStorage â†’ PostgreSQL)
- New features are added without changing existing code
- All layers have clear boundaries and interfaces

### Quality Criteria
- Test coverage meets target metrics
- Performance meets requirements
- Code follows SOLID principles
- Documentation covers all public APIs
- No critical and high severity bugs

## Prototype Readiness Criteria

**Domain Layer:**
- Record with content and Set<TagId>
- Tag with id and normalizedValue
- Parsing and normalization services
- Token validation

**Application Layer:**
- CreateRecord use case
- SearchRecords with auto mode detection
- UpdateRecord with duplicate checking
- DeleteRecord with tag cleanup
- GetTagSuggestions for auto-completion
- ExportData without UUIDs
- ImportData with full replacement

**Infrastructure Layer:**
- localStorage adapters
- Indexes for fast search
- deleteAll() methods for import
- JSON export/import

**Presentation Layer:**
- Single input field
- Auto list/cloud switching
- Keyboard navigation
- Loading indicators
- Import/export UI with warnings

**Testing:**
- 95% Domain coverage
- 90% Use Cases coverage
- Storage integration tests
- Import/export tests with full replacement verification

---

# PART 14: RISKS AND LIMITATIONS

## Technical Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|---------|-----------|
| Clean Architecture complexity for simple prototype | Medium | Medium | Phased implementation, starting with domain |
| Performance with large number of records | Low | High | Indexing, pagination, list virtualization |
| localStorage limits | Medium | Medium | Usage monitoring, warnings |
| Diacritic normalization issues | Low | Low | Testing with different languages, settings |
| Large bundle size | Medium | Medium | Code splitting, lazy loading, tree shaking |

## Product Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|---------|-----------|
| "Too simple" for users | Medium | High | Educational materials, usage examples |
| Confusion with "everything is tags" concept | Medium | Medium | Intuitive UI, onboarding |
| Record duplication due to typos | High | Low | Aggressive auto-completion, fuzzy search in future |
| "Too simple" for enterprise users | Medium | Medium | Focus on personal use, then team features |
| Open source monetization complexity | Medium | Medium | Cloud version, premium features, support |
| Competition with giant tech | Low | High | Ultra-minimalism niche, dedicated community |

## Organizational Risks

| Risk | Probability | Mitigation |
|------|-------------|-----------|
| Over-complication at start | High | Focus on MVP functionality |
| Long refactoring | Medium | Small iterations, continuous refactoring |
| Loss of focus | Medium | Clear readiness criteria for each phase |

## Prototype Limitations

- **Data volume**: Up to 5-10MB (localStorage limitations)
- **Multi-user support**: Absent
- **Synchronization**: Absent
- **Backup**: Only through manual export
- **Fuzzy search**: Absent (exact tag matching)
- **Change history**: Absent
- **Collaborative work**: Absent

---

# PART 15: PRODUCT DEVELOPMENT STAGES

## Prototype

- Web application with local storage
- Basic functionality: create, search, edit
- Auto-completion based on existing tags
- Data export/import
- Concept validation

## MVP

- PostgreSQL backend
- Multi-user support
- Authorization and personal spaces
- Enhanced tag auto-completion

## Scaling

- Mobile applications (PWA â†’ Native)
- CLI version for developers
- API for integrations
- Cross-device synchronization
- Export to various formats
- Browser extension

## Ecosystem

- Public and team spaces
- API for third-party developers
- Plugins and extensions
- ML suggestions (optional, without breaking simplicity)
- Premium features for monetization

## Future Preparation (NOT implemented in prototype)

### What's built into the structure
1. **Tags as entities** - will allow renaming
2. **UUIDs for everything** - will allow synchronization
3. **Normalization in one place** - easy to change rules
4. **Clean layers** - easy to replace localStorage with API
5. **Export versioning** - will allow format migrations

### What we DON'T do now
1. âŒ Events and EventBus
2. âŒ Tag renaming
3. âŒ Tag merging
4. âŒ Change history
5. âŒ Synchronization
6. âŒ Incremental import
7. âŒ Complex validation

---

# PART 16: COMPETITIVE ADVANTAGES

1. **Radical simplicity**: No analogues with such level of minimalism
2. **Zero entry barrier**: Requires no learning
3. **Open Source**: Transparency and community trust
4. **Universality**: Replaces multiple specialized tools

---

# PART 17: DEVELOPMENT TOOLS AND TECHNOLOGIES

## Required Tools

- **IDE**: VS Code with TypeScript extensions
- **Node.js**: v22.18.0 (specified in .nvmrc)
- **Yarn**: v3+ (Berry)
- **Git**: Conventional Commits

## Recommended VS Code Extensions

- ESLint
- Prettier
- Jest Runner
- GitLens
- Better Comments
- TODO Highlight

## Development Commands

```bash
# Project initialization
yarn install
yarn build

# Domain development
cd packages/domain
yarn test:watch

# Application development
cd packages/application
yarn test:watch

# Run web version
yarn dev:web

# Coverage check
yarn test:coverage

# Full check before commit
yarn lint && yarn test && yarn build
```

## Definition of Done

### For each task:
- Tests written and passing
- Code meets linter requirements
- Documentation written
- PR created and reviewed
- CI passes completely

### For each phase:
- All tasks completed
- Target metrics achieved
- Integration tests passing
- Documentation up to date
- No critical bugs

---

# PART 18: FIRST DEVELOPMENT STEPS

## 1. Create repository
```bash
git init misc
cd misc
```

## 2. Initialize yarn workspaces
```bash
yarn init -y
yarn set version berry
yarn config set nodeLinker node-modules
```

## 3. Create basic structure
```bash
mkdir -p packages/{domain,application,shared}
mkdir -p packages/infrastructure/localStorage
mkdir -p packages/presentation/{web,cli}
```

## 4. Set up TypeScript and Jest
```bash
yarn add -D typescript jest @types/jest ts-jest
yarn add -D @typescript-eslint/parser @typescript-eslint/eslint-plugin
yarn add -D prettier eslint-config-prettier
```

## 5. Create first test
```typescript
// packages/domain/tests/value-objects/RecordId.test.ts
describe('RecordId', () => {
  it('should generate unique UUID when created without value', () => {
    // Red phase - test should fail
    expect(true).toBe(false);
  });
});
```

## 6. Start TDD cycle
```bash
cd packages/domain
yarn test:watch
```

And start implementation through Red-Green-Refactor!

## TDD cycle:
1. **Red**: Write a test that fails
2. **Green**: Write minimal code to pass the test
3. **Refactor**: Improve code while keeping tests green

## Clean Architecture checklist:
- Domain doesn't know about other layers
- Application orchestrates but doesn't contain business logic
- Infrastructure implements interfaces from Application
- Presentation uses only Application layer
- Dependencies point inward

## Priorities:
1. **Working code** > Perfect architecture
2. **Simplicity** > Future flexibility
3. **Tests** > Documentation
4. **Refactoring** > Rewriting from scratch

---

# CONCLUSION

MISC is not just an information management system, it's a philosophy of radical simplicity. The project is built on Clean Architecture principles using TDD, which ensures high code quality and system evolution capability.

Key project features:
- Single principle: everything is tags
- Instant information capture
- Zero entry barrier
- Clean architecture with independent layers
- Test-driven development
- Ready for evolution and scaling

The project is ready for phased implementation, starting with the domain layer and ending with a full-featured web application with the possibility of further development into a multi-user system with synchronization and API.

Happy development! ðŸš€
